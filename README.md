# RxJava
Итак, единственная разница между двумя этими типами заключается в том, что один поддерживает backpressure, а другой — нет.
Расскажите подробнее, в каких ситуациях это требуется. Никак не могу понять, нужен ли мне Flowable.

Источники
interface Observer<T> {
    void onNext(T t);		-  Этот метод вызывается каждый раз, когда Observable или Flowable генерирует элемент, позволяя его обрабатывать произвольным образом.
    void onComplete();		- означает успешное завершение;
    void onError(Throwable t);	- означает, что либо исполнение onNext привело к исключению, либо возникла проблема на стороне источника.
    void onSubscribe(Disposable d);	- Колбэк onSubscribe вызывается сразу же, как только вы начинаете прослушивать Observable или Flowable, и он передаст вам объект одного из двух типов: Disposable.
}




interface Subscriber<T> {
    void onNext(T t);
    void onComplete();
    void onError(Throwable t);
    void onSubscribe(Subscription s);
}



interface Disposable {
    void dispose();	- «Я закончил работать с этим ресурсом, мне больше не нужны данные»
}


interface Subscription {
    void cancel();	-«Я закончил работать с этим ресурсом, мне больше не нужны данные»
    void request(long r);	-backpressure C помощью этого метода мы говорим Flowable, что нам нужно больше элементов.		???
}


interface DisposableObserver		- который автоматически обработает onSubscribe, так что вам достаточно будет позаботиться лишь об уведомлениях от самого Observable.
когда надо отписаться DisposableObserver.dispose();

-------------------------------------
Специализированные источники

Single (onNext(1 item)/onError/onSubscribe)	
		- Он либо содержит один элемент, либо выдаёт ошибку.Можете представлять его себе как обычный метод. Вы вызываете метод и получаете возвращаемое значение; либо метод 			бросает исключение

Completable (onComplete/onError/onSubscribe)	
		- Он либо успешно завершает свою работу без каких-либо данных, либо бросает исключение. То есть это некий кусок кода, который можно запустить, и он либо успешно 			выполнится, либо завершится сбоем

Maybe (onNext(1 item)/onComplete/onError/onSubscribe)
		- Он может либо содержать элемент, либо выдать ошибку, либо не содержать данных — этакий реактивный Optional


---------------------------
методы
   .observeOn(AndroidSchedulers.mainThread())              //в каком потоке просматривать
                    .subscribeOn(Schedulers.io())                           //в каком потоке выполнять
subscribe(Слушатель) - подписка на прослушивание
observer subscribeWith(DisposableObserver слушатель) - подписка на прослушивание
map		- дает возможность работать с объектом, преоразовать его в другой

------------------
Subject  - это связь между слушающим и слушателем
Observable: Предположим, что профессор является наблюдаемым(observable). Профессор учит какой-то теме.
Observer: Предположим, что студент наблюдатель(observer). Студент слушает(или наблюдает) тему, которую преподает профессор.

типы
Publish Subject		- Излучает(emit) все последующие элементы наблюдаемого источника в момент подписки.(Здесь, если студент вошел в аудиторию, он просто хочет слушать с того момента, когда он вошел в аудиторию. И так, Publish будет лучшим выбором для использования.)

Replay Subject		- Излучает(emit все элементы источника наблюдаемого(Observable), независимо от того, когда подписчик(subscriber) подписывается(Здесь, если студент с опозданием вошел в аудиторию, он хочет послушать лекцию с самого начала. И так, для этого мы должны использовать Replay.)

Behavior Subject 	- Он излучает(emit) совсем недавно созданый элемент и все последующие элементы наблюдаемого источника, когда наблюдатель(observer) присоединяется к нему.
(Здесь, если студент вошел в аудиторию, он хочет слушать самые последние вещи(не с начала) преподаваемые профессором таким образом, что он получает идею контекста. Итак, здесь мы будем использовать Behavior.)

Async Subject		- Он выдает только последнее значение наблюдаемого источника(и только последнее).
(Здесь, если студент пришел в любой момент времени в аудиторию, и он хочет слушать только о последней вещи(и только последней) которую учат. Итак, здесь мы будем использовать Async.)


